<!--
author: joshxviii
 -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Security-Policy" content="script-src 'self' 'unsafe-inline'">
    <title>Animalese TTS</title>
    <link rel="stylesheet" href="assets\styles\main.css">
    <link rel="stylesheet" href="assets\styles\keyboard.css">
    <link id="theme-style" rel="stylesheet" href="assets\styles\themes\default.css" />
</head>
<body>
    <div id="resize-border"></div>
    <div class="title-bar">
        <div style="display: flex; gap: 10px;">
            <div id="title" title="Animalese TTS">animalese tts</div>
            <div id="disabled_warning" translation="warning.enabled"></div>
        </div>

        <div style="display: flex; padding: 0px 16px; gap: 16px;">
            <svg-button onclick="console.log('Settings button clicked'); openSettings()" icon="config" title="Settings"></svg-button>
            <svg-button onclick="window.api.minimizeWindow()" icon="minimize" title="Minimize"></svg-button>
            <svg-button onclick="window.api.closeWindow()" icon="close" title="Close"></svg-button>
        </div>
    </div>

    <div id="focus_out" show="false">
    <div id="settings_overlay">
        <div class="settings_header">
            <h2 id="settings_title" translation="settings"></h2>
            <button onclick="openSettings()" class="close_button">‚úï</button>
        </div>
        <div class="separator"></div>

        <div class="catagory">
            <h3 translation="settings.lang"></h3>
            <select id="lang_select" onchange="updateLanguage(`${this.value}`)">
                <option value="en" translation="en"></option>
                <option value="es" translation="es"></option>
                <option value="de" translation="de"></option>
                <option value="fr" translation="fr"></option>
                <option value="ko" translation="ko"></option>
                <option value="ja" translation="ja"></option>
                <option value="zh_CN" translation="zh_CN"></option>
            </select>
        </div>

        <div class="catagory">
            <h3 translation="settings.theme"></h3>
            <select id="theme_select" onchange="updateTheme(`${this.value}`)">
                <option value="default" translation="settings.theme.default"></option>
                <option value="dark" translation="settings.theme.dark"></option>
                <option value="pink" translation="settings.theme.pink"></option>
                <option value="green" translation="settings.theme.green"></option>
            </select>
        </div>

        <div class="separator"></div>
        <div class="footer">
            <p onclick="window.api.goToUrl('https:\/\/github.com/joshxviii/animalese-typing-desktop')" style="cursor: pointer;">
                Animalese TTS <text id="version"></text>
            </p>
            <p style="font-size: 11px; opacity: 0.7; margin-top: 5px;">
                Licensed under MIT | <a href="#" onclick="showLicenses()" style="color: inherit;">Third-Party Licenses</a>
            </p>
        </div>
    </div>
    </div>

    <div id="main-win">
        <div id="main_content">
            <!-- ÏÉÅÎã® ÏÑπÏÖò -->
            <div id="top_section">
                <!-- ÌÜµÌï©Îêú ÌÖçÏä§Ìä∏ ÏûÖÎ†• Î∞è SRT Ìå®ÎÑê -->
                <div id="text_input_panel">
                    <!-- Î©îÏù∏ ÌÖçÏä§Ìä∏ ÏûÖÎ†• ÏòÅÏó≠ -->
                    <textarea id="tts_input" placeholder="Ïó¨Í∏∞Ïóê ÌÖçÏä§Ìä∏Î•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî..."></textarea>

                    <!-- ÌïòÎã® Î≤ÑÌäº Í∑∏Î£π -->
                    <div class="button_group">
                        <button onclick="togglePreview()" class="action_button" id="preview_button">
                            <span class="button_icon" id="preview_icon">‚ñ∂</span>
                        </button>
                        <button onclick="convertTextToWav()" class="action_button">
                            <span class="button_icon">‚¨á</span>
                        </button>
                        <button onclick="clearTTSInput()" class="action_button secondary">
                            <span class="button_icon">‚Ü∫</span>
                        </button>
                        <!-- SRT ÌååÏùº ÏÑ†ÌÉù Î≤ÑÌäº (Ïà®ÍπÄ) -->
                        <button onclick="loadSRTFile()" class="action_button srt_button" style="display: none;">
                            <span class="button_icon">üìÅ</span>
                        </button>
                        <!-- SFX Î≤ÑÌäº -->
                        <button onclick="toggleSFX()" id="sfx_button" class="action_button sfx_button" pressed="false">
                            SFX
                        </button>
                    </div>
                </div>
            </div>

            <!-- ÌïòÎã® ÏÑπÏÖò -->
            <div id="bottom_section">
                <div id="voice_profile_editor">
                    <!-- ÎßàÏä§ÌÑ∞ Î≥ºÎ•® Ïª®Ìä∏Î°§ (Ïà®ÍπÄ) -->
                    <div id="master_volume_control" style="display: none;">
                        <label class="editor_label">
                            <span translation="settings.master_volume">ÎßàÏä§ÌÑ∞ Î≥ºÎ•®</span>
                            <input id="master" class="editor_slider" type="range" min="0" max="100" step="1" value="50"></input>
                            <input type="text" id="master_value" class="editor_output" value="50%" />
                        </label>
                    </div>

                    <div id="sliders">
                        <label class="editor_label">
                            <span translation="voice.pitch">ÌîºÏπò</span>
                            <input id="voice_pitch" class="editor_slider" type="range" min="-12" max="12" step="0.1" value="0" defaultValue="0"></input>
                            <input type="text" id="voice_pitch_out" class="editor_output" />
                        </label>

                        <label id="label_editor_2" class="editor_label">
                            <span translation="voice.intonation"></span>
                            <input id="voice_intonation" class="editor_slider" type="range" min="-1" max="1" step="0.01" value="0" defaultValue="0"></input>
                            <input type="text" id="voice_intonation_out" class="editor_output" />
                        </label>

                        <label id="label_editor_3" class="editor_label">
                            <span translation="voice.variation"></span>
                            <input id="voice_variation" class="editor_slider" type="range" min="0" max="12" step="0.1" value="0" defaultValue="0"></input>
                            <input type="text" id="voice_variation_out" class="editor_output" />
                        </label>
                    </div>

                    <div id="voice_type_group">
                        <div id="voice_type_buttons">
                            <svg-button id="male" icon="male" onclick="selectVoiceType('male')" pressed="false"></svg-button>
                            <svg-button id="female" icon="female" onclick="selectVoiceType('female')" pressed="true"></svg-button>
                        </div>

                        <select id="voice_type" class="female" tabindex="-1">
                            <option id="label_f1" class="female" value="f1" translation="f1" selected></option>
                            <option id="label_f2" class="female" value="f2" translation="f2"></option>
                            <option id="label_f3" class="female" value="f3" translation="f3"></option>
                            <option id="label_f4" class="female" value="f4" translation="f4"></option>
                            <option id="label_m1" class="male" value="m1" translation="m1"></option>
                            <option id="label_m2" class="male" value="m2" translation="m2"></option>
                            <option id="label_m3" class="male" value="m3" translation="m3"></option>
                            <option id="label_m4" class="male" value="m4" translation="m4"></option>
                        </select>
                    </div>
                </div>
            </div>
        </div>
    </div>
    </div>

    <script src="./app.asar.unpacked/assets/jquery.js"></script>
    <script src="./renderer/animalese.cjs"></script>
    <script src="./renderer/editor.cjs"></script>

    <!-- TTS Engine Script -->
    <script src="./renderer/tts-engine.cjs"></script>
    <script src="./renderer/tts-ui.cjs"></script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOMContentLoaded - calling initControls from renderer/editor.cjs');
            // renderer/editor.cjsÏùò initControls Ìò∏Ï∂ú
            if (typeof initControls === 'function') {
                initControls();
            } else {
                console.error('initControls function not found in global scope');
            }
            updatedFocusedWindows();

            // TTS ÎùºÎ≤® ÌÖçÏä§Ìä∏ Ïà®Í∏∞Í∏∞ (translation="tts.xxx" ÏöîÏÜåÎì§Ïùò ÌÖçÏä§Ìä∏Îßå Ï†úÍ±∞)
            hideTTSLabels();

            // Î≤àÏó≠ ÌÖçÏä§Ìä∏ ÏúÑÏπò ÌôïÏù∏
            console.log('=== Î≤àÏó≠ ÏãúÏä§ÌÖú ÌôïÏù∏ ===');
            const pitchLabel = document.querySelector('label[translation="voice.pitch"]');
            console.log('Pitch label element:', pitchLabel);
            if (pitchLabel) {
                console.log('Pitch label children:', pitchLabel.children);
                console.log('Pitch label span:', pitchLabel.querySelector('span'));
                console.log('Pitch label span content:', pitchLabel.querySelector('span')?.textContent);
                console.log('Pitch label translation attr:', pitchLabel.getAttribute('translation'));
                console.log('Pitch label textContent:', pitchLabel.textContent);
            }
            console.log('=== Î≤àÏó≠ ÏãúÏä§ÌÖú ÌôïÏù∏ ÏôÑÎ£å ===');

            // 1Ï¥à ÌõÑ Îã§Ïãú ÌôïÏù∏ (Î≤àÏó≠ ÏãúÏä§ÌÖú Î°úÎìú ÌõÑ)
            setTimeout(() => {
                console.log('=== Î≤àÏó≠ ÌõÑ ÏÉÅÌÉú ÌôïÏù∏ ===');
                if (pitchLabel) {
                    console.log('Pitch label textContent after translation:', pitchLabel.textContent);
                    console.log('Pitch label span content after translation:', pitchLabel.querySelector('span')?.textContent);
                }
                console.log('=== Î≤àÏó≠ ÌõÑ ÏÉÅÌÉú ÌôïÏù∏ ÏôÑÎ£å ===');
            }, 1000);

            // TTS Ï¥àÍ∏∞Ìôî
            const initTTSWhenReady = setInterval(() => {
                if (window.audio && window.TTSEngine && !window.ttsInitialized) {
                    console.log('TTS Ï¥àÍ∏∞Ìôî ÏãúÎèÑ...');
                    initTTS(window.audio);
                    loadVoiceProfiles();
                    window.ttsInitialized = true;
                    clearInterval(initTTSWhenReady);
                }
            }, 100);

            // settings Îã´Í∏∞
            const focusOut = document.getElementById('focus_out');
            const settingsOverlay = document.getElementById('settings_overlay');
            focusOut.addEventListener('mousedown', function(event) {
                if (focusOut.getAttribute('show') === 'true' && !settingsOverlay.contains(event.target)) {
                    focusOut.setAttribute('show', 'false');
                }
            });
        });

        function initControls() {
            console.log('initControls() called');
            console.log("Initializing controls...");

            // Master volume
            const master = document.getElementById('master');
            const masterValue = document.getElementById('master_value');
            console.log('Master element:', master);
            console.log('MasterValue element:', masterValue);

            if (master) {
                console.log('Setting master volume slider...');
                // Ensure value is always 0-100
                const savedVolume = preferences.get('volume');
                const initialValue = savedVolume !== undefined && savedVolume !== null
                    ? Math.min(100, Math.max(0, Math.floor(savedVolume * 100)))
                    : 50;
                master.value = initialValue;
                if (masterValue) {
                    masterValue.textContent = `${master.value}%`;
                }

                // ÎßàÏä§ÌÑ∞ Î≥ºÎ•® Ïä¨ÎùºÏù¥Îçî Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Ï∂îÍ∞Ä
                master.addEventListener('input', (e) => {
                    const volume = e.target.value / 100; // 0-100ÏùÑ 0-1Î°ú Î≥ÄÌôò
                    console.log('Master volume slider changed:', volume);

                    // preferencesÏóê Ï†ÄÏû•
                    preferences.set('volume', volume);

                    // audioManagerÏóê ÏßÅÏ†ë ÏÑ§Ï†ï (IPC Í≤ΩÏú† ÏóÜÏù¥ Ï¶âÏãú Î∞òÏòÅ)
                    if (window.audio && window.audio.setMasterVolume) {
                        window.audio.setMasterVolume(volume);
                        console.log('Audio manager volume updated');
                    }

                    if (masterValue) {
                        masterValue.textContent = `${e.target.value}%`;
                    }
                });

                console.log('Master volume event listener added');
            } else {
                console.error('Master element not found!');
            }

            // Voice profile controls
            initVoiceControls();
        }

        function initVoiceControls() {
            // Voice pitch
            const voicePitch = document.getElementById('voice_pitch');
            const voicePitchOut = document.getElementById('voice_pitch_out');
            if (voicePitch && voicePitchOut) {
                voicePitchOut.value = voicePitch.value;
                voicePitch.addEventListener('input', (e) => {
                    voicePitchOut.value = e.target.value;
                    preferences.set('voice_profile.pitch', parseFloat(e.target.value));
                });
            }

            // Voice intonation
            const voiceIntonation = document.getElementById('voice_intonation');
            const voiceIntonationOut = document.getElementById('voice_intonation_out');
            if (voiceIntonation && voiceIntonationOut) {
                voiceIntonationOut.value = voiceIntonation.value;
                voiceIntonation.addEventListener('input', (e) => {
                    voiceIntonationOut.value = e.target.value;
                    preferences.set('voice_profile.intonation', parseFloat(e.target.value));
                });
            }

            // Voice variation
            const voiceVariation = document.getElementById('voice_variation');
            const voiceVariationOut = document.getElementById('voice_variation_out');
            if (voiceVariation && voiceVariationOut) {
                voiceVariationOut.value = voiceVariation.value;
                voiceVariation.addEventListener('input', (e) => {
                    voiceVariationOut.value = e.target.value;
                    preferences.set('voice_profile.variation', parseFloat(e.target.value));
                });
            }

            // Voice type
            const voiceType = document.getElementById('voice_type');
            if (voiceType) {
                voiceType.addEventListener('change', (e) => {
                    console.log('Voice type changed to:', e.target.value);
                    preferences.set('voice_profile.type', e.target.value);
                    updateVoiceTypeButtons(e.target.value);
                });
            }
        }

        function updateVoiceTypeButtons(selectedType) {
            const maleButton = document.getElementById('male');
            const femaleButton = document.getElementById('female');
            const voiceTypeSelect = document.getElementById('voice_type');

            if (maleButton && femaleButton && voiceTypeSelect) {
                const isMale = selectedType.startsWith('m');
                voiceTypeSelect.className = isMale ? 'male' : 'female';

                document.querySelectorAll('option').forEach(option => {
                    if (option.className === 'male') {
                        option.style.display = isMale ? 'block' : 'none';
                    } else if (option.className === 'female') {
                        option.style.display = isMale ? 'none' : 'block';
                    }
                });
            }
        }

        function updatedFocusedWindows() {
            // Stub function for compatibility
        }

        function toggleSFX() {
            const sfxButton = document.getElementById('sfx_button');
            const currentState = sfxButton.getAttribute('pressed');
            const newState = currentState === 'true' ? 'false' : 'true';
            sfxButton.setAttribute('pressed', newState);
            console.log('SFX button toggled:', newState);
        }

        // Ï†ÑÏó≠ Ïä§ÏΩîÌîÑÏóê Î∞îÏù∏Îî©
        window.toggleSFX = toggleSFX;

        // ÎØ∏Î¶¨Îì£Í∏∞ ÌÜ†Í∏Ä Ìï®Ïàò
        function togglePreview() {
            if (window.previewAudio) {
                console.log('ÎØ∏Î¶¨Îì£Í∏∞ Î©àÏ∂§');
                window.previewAudio.pause();
                window.previewAudio = null;
                updatePreviewButtonState(false);
            } else {
                console.log('ÎØ∏Î¶¨Îì£Í∏∞ ÏãúÏûë');
                previewTTS();
            }
        }

        // Î©àÏ∂§ Ìï®Ïàò (Ìò∏ÌôòÏÑ±ÏùÑ ÏúÑÌï¥ Ïú†ÏßÄ)
        function stopPreview() {
            if (window.previewAudio) {
                console.log('ÎØ∏Î¶¨Îì£Í∏∞ Î©àÏ∂§');
                const url = window.previewAudio.previewUrl;
                window.previewAudio.pause();
                window.previewAudio.currentTime = 0;
                window.previewAudio = null;
                if (url && url.startsWith('blob:')) {
                    URL.revokeObjectURL(url);
                }
                updatePreviewButtonState(false);
            }
        }

        // ÎØ∏Î¶¨Îì£Í∏∞ Î≤ÑÌäº ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
        function updatePreviewButtonState(isPlaying) {
            const previewButton = document.getElementById('preview_button');
            const previewIcon = document.getElementById('preview_icon');
            if (previewButton && previewIcon) {
                previewIcon.textContent = isPlaying ? '‚è∏' : '‚ñ∂';
            }
        }

        // Ï†ÑÏó≠ÏúºÎ°ú Îì±Î°ù
        window.stopPreview = stopPreview;
        window.togglePreview = togglePreview;

        // SRT Î©îÏãúÏßÄ ÏàòÏã† Ï†ÑÏó≠ Ìï®Ïàò
        window.receiveSRTMessage = function(data) {
            console.log('SRT message received in main window:', data);

            if (data.type === 'srt-cues-selected') {
                console.log('SRT cues selected:', data.cues.length, 'cues');
            } else if (data.type === 'srt-cues-convert') {
                console.log('Converting selected SRT cues:', data.cues.length, 'cues');
                if (typeof convertCueListToWav === 'function') {
                    convertCueListToWav(data.cues);
                }
            } else if (data.type === 'srt-cues-convert-all') {
                console.log('Converting all SRT cues:', data.cues.length, 'cues');
                if (typeof convertCueListToWav === 'function') {
                    convertCueListToWav(data.cues);
                }
            } else if (data.type === 'srt-convert-all') {
                console.log('Converting entire SRT to single WAV file');
                if (typeof convertAllSRT === 'function') {
                    convertAllSRT();
                } else {
                    console.error('convertAllSRT function not found');
                }
            }
        };

        // SRT Ï∞Ω Î©îÏãúÏßÄ Î¶¨Ïä§ÎÑà Ï∂îÍ∞Ä
        window.addEventListener('message', (event) => {
            console.log('Message from SRT window:', event.data);

            if (event.data.type === 'srt-cues-selected') {
                // ÏÑ†ÌÉùÎêú cues Ï≤òÎ¶¨
                console.log('SRT cues selected:', event.data.cues.length, 'cues');
                // TODO: ÏÑ†ÌÉùÎêú cuesÎ°ú Ï∂îÍ∞Ä Ï≤òÎ¶¨
            } else if (event.data.type === 'srt-cues-convert') {
                // ÏÑ†ÌÉùÎêú cues Î≥ÄÌôò
                console.log('Converting selected SRT cues:', event.data.cues.length, 'cues');
                if (typeof convertCueListToWav === 'function') {
                    convertCueListToWav(event.data.cues);
                }
            } else if (event.data.type === 'srt-cues-convert-all') {
                // Ï†ÑÏ≤¥ cues Î≥ÄÌôò
                console.log('Converting all SRT cues:', event.data.cues.length, 'cues');
                if (typeof convertCueListToWav === 'function') {
                    convertCueListToWav(event.data.cues);
                }
            } else if (event.data.type === 'srt-convert-all') {
                // Ï†ÑÏ≤¥ SRTÎ•º ÌïòÎÇòÏùò WAV ÌååÏùºÎ°ú Î≥ÄÌôò
                console.log('Converting entire SRT to single WAV file');
                if (typeof convertAllSRT === 'function') {
                    convertAllSRT();
                } else {
                    console.error('convertAllSRT function not found');
                }
            }
        });

        // Electron IPCÎ•º ÌÜµÌïú SRT Î©îÏãúÏßÄ ÏàòÏã†
        if (window.api && window.api.onSRTMessage) {
            window.api.onSRTMessage((data) => {
                console.log('SRT message received via IPC:', data);

                if (data.type === 'srt-cues-selected') {
                    console.log('SRT cues selected:', data.cues.length, 'cues');
                } else if (data.type === 'srt-cues-convert') {
                    console.log('Converting selected SRT cues:', data.cues.length, 'cues');
                    if (typeof convertCueListToWav === 'function') {
                        convertCueListToWav(data.cues);
                    }
                } else if (data.type === 'srt-cues-convert-all') {
                    console.log('Converting all SRT cues:', data.cues.length, 'cues');
                    if (typeof convertCueListToWav === 'function') {
                        convertCueListToWav(data.cues);
                    }
                } else if (data.type === 'srt-convert-all') {
                    console.log('Converting entire SRT to single WAV file');
                    if (typeof convertAllSRT === 'function') {
                        convertAllSRT();
                    } else {
                        console.error('convertAllSRT function not found');
                    }
                }
            });
        }

        function openSettings() {
            console.log('=== openSettings() called ===');
            const focusOut = document.getElementById('focus_out');
            const isShown = focusOut.getAttribute('show') === 'true';
            console.log('Current show attribute:', focusOut.getAttribute('show'));
            console.log('Current state:', isShown ? 'shown' : 'hidden');

            const newState = isShown ? 'false' : 'true';
            console.log('Setting to:', newState);

            focusOut.setAttribute('show', newState);

            // Ï¶âÏãú ÌôïÏù∏
            console.log('After toggle - show attribute:', focusOut.getAttribute('show'));
            console.log('After toggle - computed visibility:', window.getComputedStyle(focusOut).visibility);
            console.log('After toggle - computed opacity:', window.getComputedStyle(focusOut).opacity);
            console.log('After toggle - computed zIndex:', window.getComputedStyle(focusOut).zIndex);
            console.log('=== openSettings() done ===');
        }

        // Ï†ÑÏó≠ Ïä§ÏΩîÌîÑÏóê Î™ÖÏãúÏ†ÅÏúºÎ°ú Î∞îÏù∏Îî©
        window.openSettings = openSettings;

        function showLicenses() {
            const licensesText =
`Third-Party Licenses

This software uses the following third-party libraries:

‚Ä¢ Electron (MIT) - https://github.com/electron/electron
‚Ä¢ FFmpeg (LGPL v2.1+) - https://ffmpeg.org/
‚Ä¢ howler.js (MIT) - https://github.com/goldfire/howler.js
‚Ä¢ electron-store (MIT) - https://github.com/sindresorhus/electron-store
‚Ä¢ electron-builder (MIT) - https://github.com/electron-userland/electron-builder

FFmpeg License Compliance:
This application uses FFmpeg in accordance with LGPL v2.1+ license.
FFmpeg is bundled with this application for user convenience.
FFmpeg is dynamically linked and located at resources/ffmpeg/ffmpeg.exe.
Users may replace FFmpeg with their own LGPL-compliant version.

For complete license information, see:
‚Ä¢ LICENSE (Main project license)
‚Ä¢ THIRD-PARTY-LICENSES.md (Detailed third-party licenses)
‚Ä¢ FFMPEG_SETUP.md (FFmpeg setup guide)

¬© 2025 joshxviii
Released under MIT License
`;
            alert(licensesText);
        }
        window.showLicenses = showLicenses;

        function saveVoiceProfile() {
            console.log('Save voice profile');
        }

        function deleteVoiceProfile() {
            console.log('Delete voice profile');
        }

        function loadVoiceProfile() {
            console.log('Load voice profile');
        }

        /**
         * TTS ÎùºÎ≤® ÌÖçÏä§Ìä∏ Ïà®Í∏∞Í∏∞
         * translation="tts.xxx" ÏÜçÏÑ±ÏùÑ Í∞ÄÏßÑ ÏöîÏÜåÎì§Ïùò ÌÖçÏä§Ìä∏Î•º Ï†úÍ±∞
         */
        function hideTTSLabels() {
            // "tts." Ï†ëÎëêÏñ¥Í∞Ä Î∂ôÏùÄ translation ÏÜçÏÑ±ÏùÑ Í∞ÄÏßÑ Î™®Îì† ÏöîÏÜå Ï∞æÍ∏∞
            const ttsElements = document.querySelectorAll('[translation^="tts."]');

            ttsElements.forEach(element => {
                // ÏöîÏÜåÏùò ÌÖçÏä§Ìä∏Îßå Ï†úÍ±∞ (translation ÏÜçÏÑ±ÏùÄ Ïú†ÏßÄ)
                element.textContent = '';

                // CSSÎ°ú visibility hidden Ï†úÍ±∞ (JavaScriptÎ°ú Ï†úÏñ¥)
                element.style.visibility = '';
                element.style.fontSize = '';
                element.style.lineHeight = '';
                element.style.height = '';
                element.style.margin = '';
                element.style.padding = '';
                element.style.overflow = '';
            });

            console.log(`TTS ÎùºÎ≤® ${ttsElements.length}Í∞ú Ïà®ÍπÄ Ï≤òÎ¶¨Îê®`);
        }
    </script>
</body>
</html>
